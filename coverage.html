
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>payment: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/hanifbg/landing_backend/internal/service/payment/impl.go (89.7%)</option>
				
				<option value="file1">github.com/hanifbg/landing_backend/internal/service/payment/init.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package payment

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/hanifbg/landing_backend/internal/model/entity"
        "github.com/hanifbg/landing_backend/internal/model/request"
        "github.com/hanifbg/landing_backend/internal/model/response"
        "github.com/midtrans/midtrans-go"
        "github.com/midtrans/midtrans-go/snap"
)

func (s *PaymentService) CreateOrder(req request.CreateOrderRequest) (*response.OrderResponse, error) <span class="cov8" title="1">{
        // Get cart with items
        cart, err := s.cartRepo.GetCartWithItems(req.CartID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get cart: %v", err)
        }</span>

        <span class="cov8" title="1">if len(cart.CartItems) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cart is empty")
        }</span>

        // Calculate totals
        <span class="cov8" title="1">subtotal := 0.0
        for _, item := range cart.CartItems </span><span class="cov8" title="1">{
                subtotal += float64(item.Quantity) * item.ProductVariant.Price
        }</span>

        // Check for discount
        <span class="cov8" title="1">var discountAmount float64 = 0
        var discountCode string

        // Create order
        orderID := uuid.New().String()
        order := &amp;entity.Order{
                ID:              orderID,
                CartID:          req.CartID,
                CustomerName:    req.CustomerName,
                CustomerEmail:   req.CustomerEmail,
                CustomerPhone:   req.CustomerPhone,
                ShippingAddress: req.ShippingAddress,
                Subtotal:        subtotal,
                DiscountAmount:  discountAmount,
                DiscountCode:    discountCode,
                ShippingCost:    0, // Implement shipping cost calculation if needed
                TotalAmount:     subtotal - discountAmount,
                OrderStatus:     "pending",
                Notes:           req.Notes,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        // Create order items
        orderItems := make([]entity.OrderItem, 0)
        for _, cartItem := range cart.CartItems </span><span class="cov8" title="1">{
                orderItem := entity.OrderItem{
                        ID:               uuid.New().String(),
                        OrderID:          orderID,
                        ProductVariantID: cartItem.ProductVariantID,
                        Quantity:         cartItem.Quantity,
                        UnitPrice:        cartItem.ProductVariant.Price,
                        Subtotal:         float64(cartItem.Quantity) * cartItem.ProductVariant.Price,
                        CreatedAt:        time.Now(),
                        UpdatedAt:        time.Now(),
                }
                orderItems = append(orderItems, orderItem)
        }</span>

        // Save order to database
        <span class="cov8" title="1">if err := s.paymentRepo.CreateOrder(order); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create order: %v", err)
        }</span>

        // Save order items
        <span class="cov8" title="1">for i := range orderItems </span><span class="cov8" title="1">{
                if err := s.paymentRepo.CreateOrderItem(&amp;orderItems[i]); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create order item: %v", err)
                }</span>
        }

        // Prepare response
        <span class="cov8" title="1">itemResponses := make([]response.OrderItemResponse, 0)
        for _, item := range orderItems </span><span class="cov8" title="1">{
                variant, err := s.cartRepo.GetProductVariantByID(item.ProductVariantID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get product variant: %v", err)
                }</span>

                <span class="cov8" title="1">itemResponses = append(itemResponses, response.OrderItemResponse{
                        ID:               item.ID,
                        ProductVariantID: item.ProductVariantID,
                        VariantName:      variant.Name,
                        Quantity:         item.Quantity,
                        UnitPrice:        item.UnitPrice,
                        Subtotal:         item.Subtotal,
                        ImageURL:         variant.ImageURL,
                        Attributes:       variant.AttributeValues,
                })</span>
        }

        <span class="cov8" title="1">orderResponse := &amp;response.OrderResponse{
                ID:              order.ID,
                CartID:          order.CartID,
                CustomerName:    order.CustomerName,
                CustomerEmail:   order.CustomerEmail,
                CustomerPhone:   order.CustomerPhone,
                ShippingAddress: order.ShippingAddress,
                Subtotal:        order.Subtotal,
                DiscountAmount:  order.DiscountAmount,
                DiscountCode:    order.DiscountCode,
                ShippingCost:    order.ShippingCost,
                TotalAmount:     order.TotalAmount,
                OrderStatus:     order.OrderStatus,
                Notes:           order.Notes,
                Items:           itemResponses,
                CreatedAt:       order.CreatedAt,
        }

        return orderResponse, nil</span>
}

func (s *PaymentService) GetOrder(orderID string) (*response.OrderResponse, error) <span class="cov8" title="1">{
        // Get order with items
        order, err := s.paymentRepo.GetOrderWithItems(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get order: %v", err)
        }</span>

        // Prepare response
        <span class="cov8" title="1">itemResponses := make([]response.OrderItemResponse, 0)
        for _, item := range order.OrderItems </span><span class="cov8" title="1">{
                itemResponses = append(itemResponses, response.OrderItemResponse{
                        ID:               item.ID,
                        ProductVariantID: item.ProductVariantID,
                        VariantName:      item.ProductVariant.Name,
                        Quantity:         item.Quantity,
                        UnitPrice:        item.UnitPrice,
                        Subtotal:         item.Subtotal,
                        ImageURL:         item.ProductVariant.ImageURL,
                        Attributes:       item.ProductVariant.AttributeValues,
                })
        }</span>

        <span class="cov8" title="1">orderResponse := &amp;response.OrderResponse{
                ID:              order.ID,
                CartID:          order.CartID,
                CustomerName:    order.CustomerName,
                CustomerEmail:   order.CustomerEmail,
                CustomerPhone:   order.CustomerPhone,
                ShippingAddress: order.ShippingAddress,
                Subtotal:        order.Subtotal,
                DiscountAmount:  order.DiscountAmount,
                DiscountCode:    order.DiscountCode,
                ShippingCost:    order.ShippingCost,
                TotalAmount:     order.TotalAmount,
                OrderStatus:     order.OrderStatus,
                Notes:           order.Notes,
                Items:           itemResponses,
                CreatedAt:       order.CreatedAt,
        }

        return orderResponse, nil</span>
}

func (s *PaymentService) CreatePayment(orderID string) (*response.PaymentResponse, error) <span class="cov8" title="1">{
        // Get order
        order, err := s.paymentRepo.FindOrderByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get order: %v", err)
        }</span>

        // Check if payment already exists
        <span class="cov8" title="1">existingPayment, err := s.paymentRepo.FindPaymentByOrderID(orderID)
        if err == nil &amp;&amp; existingPayment != nil </span><span class="cov8" title="1">{
                // Payment already exists, return it
                return &amp;response.PaymentResponse{
                        ID:            existingPayment.ID,
                        OrderID:       existingPayment.OrderID,
                        Amount:        existingPayment.Amount,
                        Status:        existingPayment.Status,
                        PaymentMethod: string(existingPayment.PaymentMethod),
                        TransactionID: existingPayment.TransactionID,
                        PaymentToken:  existingPayment.PaymentToken,
                        PaymentURL:    existingPayment.PaymentURL,
                        ExpiryTime:    existingPayment.ExpiryTime,
                        CreatedAt:     existingPayment.CreatedAt,
                }, nil
        }</span>

        // Create Midtrans transaction
        // Create Snap request
        <span class="cov8" title="1">req := &amp;snap.Request{
                TransactionDetails: midtrans.TransactionDetails{
                        OrderID:  orderID,
                        GrossAmt: int64(order.TotalAmount),
                },
                CustomerDetail: &amp;midtrans.CustomerDetails{
                        FName: order.CustomerName,
                        Email: order.CustomerEmail,
                        Phone: order.CustomerPhone,
                        ShipAddr: &amp;midtrans.CustomerAddress{
                                Address: order.ShippingAddress,
                        },
                },
                EnabledPayments: []snap.SnapPaymentType{
                        snap.PaymentTypeBankTransfer,
                        snap.PaymentTypeGopay,
                        snap.PaymentTypeShopeepay,
                        snap.PaymentTypeCreditCard,
                },
                Callbacks: &amp;snap.Callbacks{
                        Finish: "https://example.com/callback", // Replace with your callback URL
                },
        }

        // Create transaction
        respSnap, err := s.snapClient.CreateTransaction(req)
        if err != nil </span><span class="cov8" title="1">{
                // Check if it's a real error (not a typed nil)
                // Convert to string to safely check if it's a meaningful error
                errorStr := fmt.Sprintf("%v", err)
                if errorStr != "&lt;nil&gt;" &amp;&amp; errorStr != "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to create Midtrans transaction: %v", err)
                }</span>
        }
        
        <span class="cov8" title="1">if respSnap == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create Midtrans transaction: response is nil")
        }</span>
        
        <span class="cov8" title="1">if respSnap.Token == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Midtrans transaction: token is empty")
        }</span>
        <span class="cov8" title="1">if respSnap.RedirectURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Midtrans transaction: redirect URL is empty")
        }</span>

        // Set expiry time (24 hours from now)
        <span class="cov8" title="1">expiryTime := time.Now().Add(24 * time.Hour)

        // Create payment record
        payment := &amp;entity.Payment{
                ID:              uuid.New().String(),
                OrderID:         orderID,
                Amount:          order.TotalAmount,
                Status:          entity.PaymentStatusPending,
                PaymentToken:    respSnap.Token,
                PaymentURL:      respSnap.RedirectURL,
                ExpiryTime:      &amp;expiryTime,
                PaymentDetails:  entity.JSONMap{},
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        // Save payment to database
        if err := s.paymentRepo.CreatePayment(payment); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create payment: %v", err)
        }</span>

        // Return payment response
        <span class="cov8" title="1">return &amp;response.PaymentResponse{
                ID:            payment.ID,
                OrderID:       payment.OrderID,
                Amount:        payment.Amount,
                Status:        payment.Status,
                PaymentToken:  payment.PaymentToken,
                PaymentURL:    payment.PaymentURL,
                ExpiryTime:    payment.ExpiryTime,
                CreatedAt:     payment.CreatedAt,
        }, nil</span>
}

func (s *PaymentService) GetPaymentStatus(paymentID string) (*response.PaymentStatusResponse, error) <span class="cov8" title="1">{
        // Get payment
        payment, err := s.paymentRepo.FindPaymentByID(paymentID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get payment: %v", err)
        }</span>

        // Return payment status response
        <span class="cov8" title="1">return &amp;response.PaymentStatusResponse{
                ID:              payment.ID,
                OrderID:         payment.OrderID,
                Status:          payment.Status,
                TransactionID:   payment.TransactionID,
                TransactionTime: payment.TransactionTime,
                PaymentMethod:   string(payment.PaymentMethod),
                Amount:          payment.Amount,
                UpdatedAt:       payment.UpdatedAt,
        }, nil</span>
}

func (s *PaymentService) HandlePaymentNotification(notification request.PaymentNotificationRequest) error <span class="cov8" title="1">{
        // Extract transaction ID and order ID
        transactionID := notification.TransactionID
        if transactionID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid transaction_id")
        }</span>

        <span class="cov8" title="1">orderID := notification.OrderID
        if orderID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid order_id")
        }</span>

        // Get payment by order ID
        <span class="cov8" title="1">payment, err := s.paymentRepo.FindPaymentByOrderID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("payment not found: %v", err)
        }</span>

        // Update transaction ID if not set
        <span class="cov8" title="1">if payment.TransactionID == "" </span><span class="cov8" title="1">{
                payment.TransactionID = transactionID
        }</span>

        // Extract transaction status
        <span class="cov8" title="1">transactionStatus := notification.TransactionStatus
        if transactionStatus == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid transaction_status")
        }</span>

        // Extract payment type
        <span class="cov8" title="1">paymentType := notification.PaymentType
        if paymentType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid payment_type")
        }</span>

        // Map payment type to PaymentMethod
        <span class="cov8" title="1">switch paymentType </span>{
        case "credit_card":<span class="cov8" title="1">
                payment.PaymentMethod = entity.PaymentMethodCreditCard</span>
        case "bank_transfer":<span class="cov8" title="1">
                payment.PaymentMethod = entity.PaymentMethodBankTransfer</span>
        case "gopay", "shopeepay":<span class="cov0" title="0">
                payment.PaymentMethod = entity.PaymentMethodEWallet</span>
        case "qris":<span class="cov0" title="0">
                payment.PaymentMethod = entity.PaymentMethodQRIS</span>
        case "cstore":<span class="cov0" title="0">
                payment.PaymentMethod = entity.PaymentMethodRetailOutlet</span>
        }

        // Extract transaction time
        <span class="cov8" title="1">transactionTimeStr := notification.TransactionTime
        if transactionTimeStr != "" </span><span class="cov8" title="1">{
                var transactionTime time.Time
                transactionTime, err = time.Parse("2006-01-02 15:04:05", transactionTimeStr)
                if err == nil </span><span class="cov8" title="1">{
                        payment.TransactionTime = &amp;transactionTime
                }</span>
        }

        // Update payment status based on transaction status
        <span class="cov8" title="1">var paymentStatus entity.PaymentStatus
        var orderStatus string

        switch transactionStatus </span>{
        case "capture", "settlement":<span class="cov8" title="1">
                paymentStatus = entity.PaymentStatusSuccess
                orderStatus = "processing"</span>
        case "pending":<span class="cov8" title="1">
                paymentStatus = entity.PaymentStatusPending
                orderStatus = "pending"</span>
        case "deny", "cancel", "expire":<span class="cov8" title="1">
                paymentStatus = entity.PaymentStatusFailed
                orderStatus = "cancelled"</span>
        case "refund":<span class="cov0" title="0">
                paymentStatus = entity.PaymentStatusRefunded
                orderStatus = "refunded"</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown transaction status: %s", transactionStatus)</span>
        }

        // Update payment status
        <span class="cov8" title="1">payment.Status = paymentStatus
        payment.UpdatedAt = time.Now()

        // Store full notification data in payment details
        paymentDetails := entity.JSONMap{}
        paymentDetailsBytes, err := json.Marshal(notification)
        if err == nil </span><span class="cov8" title="1">{
                if err := json.Unmarshal(paymentDetailsBytes, &amp;paymentDetails); err == nil </span><span class="cov8" title="1">{
                        payment.PaymentDetails = paymentDetails
                }</span>
        }

        // Update payment in database
        <span class="cov8" title="1">if err := s.paymentRepo.UpdatePayment(payment); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update payment: %v", err)
        }</span>

        // Update order status
        <span class="cov8" title="1">if err := s.paymentRepo.UpdateOrderStatus(orderID, orderStatus); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update order status: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package payment

import (
        "github.com/hanifbg/landing_backend/internal/repository"
        "github.com/midtrans/midtrans-go"
        "github.com/midtrans/midtrans-go/snap"
)

// SnapClientInterface defines the interface for Midtrans Snap client
type SnapClientInterface interface {
        CreateTransaction(req *snap.Request) (*snap.Response, *midtrans.Error)
}

type PaymentService struct {
        paymentRepo repository.PaymentRepository
        cartRepo    repository.CartRepository
        snapClient  SnapClientInterface
}

func NewPaymentService(paymentRepo repository.PaymentRepository, cartRepo repository.CartRepository, snapClient SnapClientInterface) *PaymentService <span class="cov0" title="0">{
        return &amp;PaymentService{
                paymentRepo: paymentRepo,
                cartRepo:    cartRepo,
                snapClient:  snapClient,
        }
}</span>

// NewPaymentServiceWithMidtrans creates a PaymentService with a real Midtrans client
func NewPaymentServiceWithMidtrans(paymentRepo repository.PaymentRepository, cartRepo repository.CartRepository, midtransServerKey string, isProduction bool) *PaymentService <span class="cov0" title="0">{
        // Initialize Midtrans client
        // Set environment based on isProduction flag
        env := midtrans.Sandbox
        if isProduction </span><span class="cov0" title="0">{
                env = midtrans.Production
        }</span>
        
        // Correct way to initialize Snap client according to Midtrans Go SDK documentation
        <span class="cov0" title="0">var snapClient snap.Client
        snapClient.New(midtransServerKey, midtrans.EnvironmentType(env))

        return &amp;PaymentService{
                paymentRepo: paymentRepo,
                cartRepo:    cartRepo,
                snapClient:  &amp;snapClient,
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
